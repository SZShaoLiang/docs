+ 防崩溃层（熔断）应该放在调用方，因为只有调用方才知道崩溃时该如何降级处理
+ 开发人员应该参与业务领域分析，碰撞专有名词和领域划分，以方便领域模型可以在开发中真正可用，不会随着开发变形
+ 值对象只存在于领域里，而VM与DTO等存在于UI层和应用层
+ 简单对象创建使用构造器，复杂的需要构造多个依赖实体的使用工厂方法，聚合根对外唯一暴漏，service是聚合根或实体的动作和状态，一个服务可以有多个聚合根。
+ 减少使用公共库，尤其是业务相关，因为一旦使用了公共库，就限制了服务异构的技术，而且面临大规模重新部署的风险。
+ 建模时防止自己陷入ORM以及数据库关系的思考中，比如hebernate组合实体等，而要从业务出发，结合边界上下文，服务大小（感觉不是很大就是足够小而不至于太小）。
+ 演化架构师，架构师不是建筑师而是城市规划师，不要从一开始就想要设计完美精确的东西，架构师必须不断的应对变化，参考MVP模式。
+ restful的动作不足以解释业务领域，我们可以通过对动作抽象，使用restful动作操作领域动作。
+ 接口实现要“宽进严出”，业务要“严进严出”。
+ 多线程是异步的一种实现方式。
+ 异步与阻塞有4种组合方式。
+ 代码的解耦使用事件，服务的解耦用MQ。
+ 将日志视为事件流。
+ 在传统开发模式下，开发人员维护服务不超过3个，在现代开发中，自动化测试和自动部署完备的情况下，开发人员可维护5个服务，占比开发的时间也少于5%。
+ 对于复杂查询，量少的可以对外提供聚合根，跨服务多条件聚合为单一主键，缺点是需要转变CURD式开发风格；中等查询量使用数据库物化视图结合CQRS，数据库读写分离，缺点是实时性低；量大复杂查询建立查询引擎，例如前端查询引擎GraphQL或者后端查询引擎，缺点是使用成本高。
+ 对于数据权限，最后都是拼sql，JPA的criteria，Spring Data JPA的Specifitition就是现成的动态sql，或者自己实现sql标准解释器；然后什么时候拼sql，service里自己写，AOP方式，拦截器方式，还有文章里的代理方式，代理方式又有很多种，外部中间件代理，应用内部JDBC代理，外部代理又有集中式引擎和最近流行的sidecar方式。
+ 对于异常，用户输入的异常尽早捕捉，并尽早以合适的方法抛出到客户端；对于程序本身产生的异常，尽早抛出，然后需要告知调用层的或者自己没有办法确定解决办法的向上传递，其他的抛出RuntimeException，如果这个异常十分严重，则抛出Exception，中断程序。对于异常的向上传递，可以使用**Catch → Rethrow**方式。关于CheckedException和UncheckedException，*如果可以合理地期望客户端从异常中恢复，请将其作为已检查的异常。如果客户端无法执行任何操作以从异常中恢复，请将其设置为未经检查的异常*
+ 好的应用或服务有两点特征，扩展性和健壮性

